<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://patrickcap.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://patrickcap.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-03T20:35:45+00:00</updated><id>https://patrickcap.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Humans and Our Tools</title><link href="https://patrickcap.github.io/blog/2025/humans-and-our-tools/" rel="alternate" type="text/html" title="Humans and Our Tools"/><published>2025-04-23T00:00:00+00:00</published><updated>2025-04-23T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2025/humans-and-our-tools</id><content type="html" xml:base="https://patrickcap.github.io/blog/2025/humans-and-our-tools/"><![CDATA[<p>What happens to the purpose of a human once they have made a tool that helps them do something?</p> <p>When we invented the stone spear to hunt animals, this may have slowly reduced the need for skills like stealth, patience, trapping, and maybe even hand-to-hand combat. The spear allowed us to attack from a distance. It changed what it meant to hunt.</p> <p>This is what every tool does, it changes what it means to do something.</p> <p>The plow extended our farming ability, but distanced us from wild foraging.</p> <p>The Global Positioning System (GPS) gave us unprecedented navigation, but reduced the need for spatial awareness and memory.</p> <p>The calculator gave us perfect, fast numerical processing, but reduced the need for mental arithmetic.</p> <p>Tools improve our efficiency, but also change what it means to do something.</p> <p>Without a doubt, the plow, the clock, GPS, and calculators have improved our lives. I am sure that in a parallel universe where these things or similar things were never invented, the average standard of living would be worse.</p> <p>However, say we conduct a though experiment and continue this trend to infinity. As we move forward, the tools we have created can do everything we used to do. Instead of driving the plow, we watch while a tool does this for us. Instead of looking at the GPS, we watch a tool follow the GPS for us. Instead of entering inputs into a calculator, we just watch a tool set up the equation and receive the answer.</p> <p>At infinity, what does this mean for humans? What is there left for us to do? This thought experiment always brings me back to the humans from the movie “WALL-E” (if you haven’t seen this, an image search will be all you need to know).</p> <p>I also wonder if my feeling now is the same feeling people had when the first plow, GPS service, and calculator was released. Is my feeling a unique one to this moment in human history, or is it simply a repeat of how humans feel when their purpose is disrupted?</p> <p>The one thing I know is that the answer should be one that comes soon.</p>]]></content><author><name>Patrick Capaldo</name></author><category term="blogs"/><category term="artificial-intelligence"/><summary type="html"><![CDATA[What is our purpose with the tools we create?]]></summary></entry><entry><title type="html">Paths of Resistance</title><link href="https://patrickcap.github.io/blog/2025/paths-of-resistance/" rel="alternate" type="text/html" title="Paths of Resistance"/><published>2025-04-23T00:00:00+00:00</published><updated>2025-04-23T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2025/paths-of-resistance</id><content type="html" xml:base="https://patrickcap.github.io/blog/2025/paths-of-resistance/"><![CDATA[<div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/blogs/paths_of_resistance/paths-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/blogs/paths_of_resistance/paths-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/blogs/paths_of_resistance/paths-1400.webp"/> <img src="/assets/img/blogs/paths_of_resistance/paths.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Paths of resistance. </div> <p>What are the pros and cons of using a GPS to navigate? Or a calculator to do simple arithmetic?</p> <p>Conversely, what are the pros and cons of growing your own food? Or doing all your research only via books in a library?</p> <p>These are all examples of paths of resistance.</p> <p>In our current era, exploiting the ease of using GPS or calculators is an example of taking a path of low resistance. There is nothing inherently wrong with this. Using a GPS will probably get you to your destination faster and using a calculator will probably help you to finish your work quicker, meaning you can spend more time doing what you like or spending time with your friends and family. However, the more parts of our lives we automate, the more skills we lose. If you only use GPS, you may lose your spatial awareness and navigation skills completely. If you only use calculators, you might not be able to tally-up prices or check if a discount is worth it when shopping. There is a cost to taking the path of low resistance.</p> <p>Conversely, in our current era, only eating what one grows or refusing to use the internet for research are examples of paths of high resistance. Again, there is nothing inherently wrong with this. Growing your own food will likely lead you to improved health and gaining important skills and knowledge about our natural world and self-sustainability. Additionally, if you only used physical books to do your research, you might read things that can’t be found on the internet, be led down rabbit holes that only the meanderings through physical aisles could cause, or even meet someone who helps you more than the internet ever would. However, the more parts of our lives we do manually, the less time we have to do other things. If you only eat food you grow, you will be limited nutritionally by your environment and you sustenance will be subject to the whims of the weather. Additionally, if you only do research via books in a library, you will miss out on billions of other sources and perspectives that no collection of books could possibly provide, let alone for you to comb through if it did exist. There is a cost to taking the path of high resistance.</p> <p>By now we can see that neither path, low nor high resistance, is ‘best’. Both have pros and cons. So, maybe the ‘best’ path is somewhere in-between - or maybe its to walk all of them, but not one for too long.</p> <p>This is also true of our world now that we have machine learning models approaching the capabilities of human intelligence. What does it mean for us to outsource critical thinking tasks? What is the purpose of a human if they simply prompt a machine learning model? Sure, we have taste and our direction and guidance is worth a lot. But at what point do we then outsource the taste and direction, since surely a path of even less resistance would be asking the machine learning model “give me some ideas yourself”, and we select from there.</p> <p>The path of least resistance is a nice one, but it gets slippery pretty fast.</p> <p>If you don’t stop and reflect every now and then, sometimes forcing yourself to take a path of higher resistance, what will you become? As I mentioned, there is nothing wrong with any of these paths. Take this article as an example, I wrote it off the top of my mind and with my own thoughts, yet utilised AI to generate the cover photo and am publishing it on the internet using my computer.</p> <p>As I said, maybe the ‘best’ path is all of them, but not one for too long.</p>]]></content><author><name>Patrick Capaldo</name></author><category term="blogs"/><category term="artificial-intelligence"/><summary type="html"><![CDATA[Paths of resistance.]]></summary></entry><entry><title type="html">Reviewing ‘The AI Economy: Work, Wealth, and Welfare in the Robot Age’</title><link href="https://patrickcap.github.io/blog/2025/book-ai-economy-bootle/" rel="alternate" type="text/html" title="Reviewing ‘The AI Economy: Work, Wealth, and Welfare in the Robot Age’"/><published>2025-02-03T00:00:00+00:00</published><updated>2025-02-03T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2025/book-ai-economy-bootle</id><content type="html" xml:base="https://patrickcap.github.io/blog/2025/book-ai-economy-bootle/"><![CDATA[<p><b>7/10</b></p> <p>‘The AI Economy’ is an optimistic, whistlestop tour of some possibilities of what increased amounts of automation and autonomy will do to our lives. If you are expecting a detailed economic analysis of some of these effects, you will not get this in this book, which is unfortunate considering the calibre of Bootle’s scientific mind. However, the ideas and surface-level analyses that Bootle does present are quite interesting, particularly for those that aren’t as economics-literate like me. For example, wealth distribution and inequality (e.g., universal basic income), increasing productivity and growth, deflation of salaries through reduced labour costs and increased competition, and inflation of AI-related goods and services (e.g., salaries, hardware, software) due to high demand. Bootle also stresses the importance of the government in monitoring the AI landscape in terms of education, innovation, regulation, and labour. In terms of future industries, obviously AI-related skills are critical, but he also presents the case for the growth of industries like travel, tourism, and leisure, as his optimistic view bolsters his confidence that our AI-augmented future will involve more people with more spare time and money. Overall, I recommended this book to read, although if you would like more detailed analysis of some of these topics, perhaps you should supplement it with another source.</p>]]></content><author><name></name></author><category term="books"/><category term="artificial-intelligence"/><summary type="html"><![CDATA[Thought-provoking but becoming dated quickly.]]></summary></entry><entry><title type="html">Exploronomics</title><link href="https://patrickcap.github.io/blog/2024/exploronomics/" rel="alternate" type="text/html" title="Exploronomics"/><published>2024-12-03T00:00:00+00:00</published><updated>2024-12-03T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2024/exploronomics</id><content type="html" xml:base="https://patrickcap.github.io/blog/2024/exploronomics/"><![CDATA[<div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/projects/exploronomics/exploronomics_globe-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/projects/exploronomics/exploronomics_globe-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/projects/exploronomics/exploronomics_globe-1400.webp"/> <img src="/assets/img/projects/exploronomics/exploronomics_globe.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Exploronomics globe. </div> <p>I’m making a tool, just for fun, to help get a feel of the economics of the countries of the world.</p> <p>Check it out <a href="https://patrickcap.github.io/exploronomics/" target="_blank">here!</a></p> <h2 id="globe-model">Globe Model</h2> <p>I did initially try to create my own 3D model of the Earth using primitive shapes linking this to a downloadable JSON file of the all the borders of every country in the world like <a href="https://geojson-maps.kyd.au/">this</a>.</p> <p>However, this proved to be quite difficult and buggy and was probably going to take a very long time to get working at a minimum, let alone optimising for performance on client-side. Note that this page contains only a frontend as GitHub Pages can only serve static content, meaning no backend server can run alongside the frontend. So all the computation must be done on client-side.</p> <p>I stumbled across <a href="https://observablehq.com/@michael-keith/draggable-globe-in-d3">this</a> draggable globe in D3.js by Michael Keith which was exactly what I was looking for and so I simply linked to this in my code.</p>]]></content><author><name>Patrick Capaldo</name></author><category term="tutorials"/><category term="economics"/><summary type="html"><![CDATA[Exploring Global Economics.]]></summary></entry><entry><title type="html">PyPuzzle 06 Descriptors and Property Generators</title><link href="https://patrickcap.github.io/blog/2024/pypuzzle-06/" rel="alternate" type="text/html" title="PyPuzzle 06 Descriptors and Property Generators"/><published>2024-07-05T00:00:00+00:00</published><updated>2024-07-05T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2024/pypuzzle-06</id><content type="html" xml:base="https://patrickcap.github.io/blog/2024/pypuzzle-06/"><![CDATA[<p>This puzzle introduces Python’s powerful <strong>descriptor protocol</strong> and the use of <strong>property decorators</strong> to control attribute access in a class.</p> <h2 id="topics-covered">Topics Covered</h2> <ul> <li>Descriptors (<code class="language-plaintext highlighter-rouge">__get__</code>, <code class="language-plaintext highlighter-rouge">__set__</code>)</li> <li>Property decorators (<code class="language-plaintext highlighter-rouge">@property</code>, <code class="language-plaintext highlighter-rouge">@&lt;name&gt;.setter</code>)</li> <li>Encapsulation and computed properties</li> </ul> <h2 id="puzzle-question">Puzzle Question</h2> <p>How does Python decide what code runs when you access or assign to an attribute? What will the following code output?</p> <h2 id="puzzle-code">Puzzle Code</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Celsius</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_temperature</span> <span class="o">=</span> <span class="n">temperature</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">temperature</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Getting value...</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_temperature</span>

    <span class="nd">@temperature.setter</span>
    <span class="k">def</span> <span class="nf">temperature</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Setting value...</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">273.15</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Temperature below absolute zero!</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_temperature</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">temp</span> <span class="o">=</span> <span class="nc">Celsius</span><span class="p">()</span>
<span class="n">temp</span><span class="p">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="mi">25</span>
<span class="nf">print</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">temperature</span><span class="p">)</span>
<span class="n">temp</span><span class="p">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="o">-</span><span class="mi">300</span>
</code></pre></div></div> <h2 id="hints">Hints</h2> <ol> <li>The <code class="language-plaintext highlighter-rouge">@property</code> decorator turns a method into a getter.</li> <li>The <code class="language-plaintext highlighter-rouge">@&lt;name&gt;.setter</code> decorator turns a method into a setter for that property.</li> <li>The setter can enforce logic or validation before changing the internal value.</li> </ol> <h2 id="answer">Answer</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Setting value...
Getting value...
25
Setting value...
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  ...
ValueError: Temperature below absolute zero!
</code></pre></div></div> <h2 id="explanation">Explanation:</h2> <ul> <li>The first assignment to <code class="language-plaintext highlighter-rouge">temp.temperature</code> calls the setter method and sets the value after printing <code class="language-plaintext highlighter-rouge">"Setting value..."</code>.</li> <li>The call to <code class="language-plaintext highlighter-rouge">print(temp.temperature)</code> invokes the getter, which prints <code class="language-plaintext highlighter-rouge">"Getting value..."</code> and returns <code class="language-plaintext highlighter-rouge">25</code>.</li> <li>The second assignment triggers the setter again, but since the value is below absolute zero, it raises a <code class="language-plaintext highlighter-rouge">ValueError</code>.</li> </ul> <h2 id="learnings">Learnings</h2> <ul> <li>Descriptors Under the Hood: The @property decorator is syntactic sugar for using Python’s descriptor protocol (<code class="language-plaintext highlighter-rouge">__get__</code>, <code class="language-plaintext highlighter-rouge">__set__</code>, <code class="language-plaintext highlighter-rouge">__delete__</code>).</li> <li>Encapsulation: Property decorators allow you to encapsulate access logic without changing how the attribute is used externally.</li> <li>Validation and Safety: Setters provide a clean way to include validation logic during assignment.</li> </ul>]]></content><author><name>Patrick Capaldo</name></author><category term="puzzles"/><category term="python"/><summary type="html"><![CDATA[Controlling attribute access in a class]]></summary></entry><entry><title type="html">PyPuzzle 05 Name Mangling and Private Variables</title><link href="https://patrickcap.github.io/blog/2024/pypuzzle-05/" rel="alternate" type="text/html" title="PyPuzzle 05 Name Mangling and Private Variables"/><published>2024-06-10T00:00:00+00:00</published><updated>2024-06-10T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2024/pypuzzle-05</id><content type="html" xml:base="https://patrickcap.github.io/blog/2024/pypuzzle-05/"><![CDATA[<p>This puzzle explores how Python handles “private” variables using <strong>name mangling</strong>, a mechanism that modifies variable names to avoid accidental access or override in subclasses.</p> <h2 id="topics-covered">Topics Covered</h2> <ul> <li>Name mangling</li> <li>Private variables in classes</li> <li>Attribute access and introspection</li> </ul> <h2 id="puzzle-question">Puzzle Question</h2> <p>Why does direct access to <code class="language-plaintext highlighter-rouge">__secret</code> raise an error, and how can it still be accessed? What will the following code print?</p> <h2 id="puzzle-code">Puzzle Code</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Spy</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">__secret</span> <span class="o">=</span> <span class="sh">"</span><span class="s">hidden</span><span class="sh">"</span>

    <span class="k">def</span> <span class="nf">reveal</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">__secret</span>

<span class="n">agent</span> <span class="o">=</span> <span class="nc">Spy</span><span class="p">()</span>
</code></pre></div></div> <h1 id="what-will-each-of-these-lines-do">What will each of these lines do?</h1> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="nf">reveal</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">__secret</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">_Spy__secret</span><span class="p">)</span>
</code></pre></div></div> <h2 id="hints">Hints</h2> <ol> <li>Double underscores at the start of a variable name trigger name mangling.</li> <li>Name mangling changes the variable name internally to avoid accidental access in subclasses.</li> <li>It’s still possible to access the variable — if you know the mangled name.</li> </ol> <h2 id="answer">Answer</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hidden
AttributeError
hidden
</code></pre></div></div> <h2 id="explanation">Explanation</h2> <ul> <li><code class="language-plaintext highlighter-rouge">agent.reveal()</code> works because it accesses <code class="language-plaintext highlighter-rouge">__secret</code> from within the class where it was defined.</li> <li><code class="language-plaintext highlighter-rouge">agent.__secret</code> raises an <code class="language-plaintext highlighter-rouge">AttributeError</code> because the name has been mangled to <code class="language-plaintext highlighter-rouge">_Spy__secret</code>.</li> <li><code class="language-plaintext highlighter-rouge">agent._Spy__secret</code> works because it manually accesses the mangled name.</li> </ul> <h2 id="learnings">Learnings</h2> <ul> <li>Name Mangling: Python uses name mangling to help protect class internals from accidental overwrites or clashes, especially in subclasses.</li> <li>Not Truly Private: Python doesn’t have true private variables — name mangling is only a convention-based safeguard.</li> <li>Debugging &amp; Introspection: Understanding name mangling is important when debugging, using <code class="language-plaintext highlighter-rouge">dir()</code>, or reflecting on class attributes.</li> </ul>]]></content><author><name>Patrick Capaldo</name></author><category term="puzzles"/><category term="python"/><summary type="html"><![CDATA[How private variables are handled using name mangling.]]></summary></entry><entry><title type="html">PyPuzzle 04 Method Resolution Order</title><link href="https://patrickcap.github.io/blog/2024/pypuzzle-04/" rel="alternate" type="text/html" title="PyPuzzle 04 Method Resolution Order"/><published>2024-05-13T00:00:00+00:00</published><updated>2024-05-13T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2024/pypuzzle-04</id><content type="html" xml:base="https://patrickcap.github.io/blog/2024/pypuzzle-04/"><![CDATA[<p>This weeks PyPuzzle will test your knowledge of the Method Resolution Order (MRO) and the C3 linearisation algorithm that determines the order in which classes are inherited and methods are resolved.</p> <ul> <li>Inheritance and method resolution</li> <li>Method Resolution Order (MRO)</li> <li>The <code class="language-plaintext highlighter-rouge">super()</code> function</li> </ul> <p>Feel free to use an online Python compiler and interpreter like [this] (https://www.online-python.com/) to try running the code yourself. The answer is supplied below the code.</p> <h2 id="question">Question</h2> <p>What is the expected output of the following code?</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">show</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">show</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">D</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">show</span><span class="p">()</span>

<span class="n">d</span> <span class="o">=</span> <span class="nc">D</span><span class="p">()</span>
<span class="n">d</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>

</code></pre></div></div> <h2 id="hints">Hints</h2> <ol> <li>Python uses the C3 linearization algorithm to determine the MRO of a class. What does the MRO look like for <code class="language-plaintext highlighter-rouge">D</code>?</li> <li>The <code class="language-plaintext highlighter-rouge">super()</code> function doesn’t always refer to the immediate parent class. Instead, it follows the MRO.</li> <li>How do multiple inheritance and <code class="language-plaintext highlighter-rouge">super()</code> calls interact?</li> </ol> <h2 id="answer">Answer</h2> <p>The output is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D
B
C
A

</code></pre></div></div> <ul> <li>MRO (Method Resolution Order): The MRO for class <code class="language-plaintext highlighter-rouge">D</code> is determined using the C3 linearization algorithm. The MRO for <code class="language-plaintext highlighter-rouge">D</code> is: <code class="language-plaintext highlighter-rouge">[D, B, C, A]</code>.</li> <li>When <code class="language-plaintext highlighter-rouge">d.show()</code> is called: <ul> <li><code class="language-plaintext highlighter-rouge">D.show()</code> is executed first and prints <code class="language-plaintext highlighter-rouge">D</code>. It then calls <code class="language-plaintext highlighter-rouge">super().show()</code>, which refers to the next class in the MRO, <code class="language-plaintext highlighter-rouge">B</code>.</li> <li><code class="language-plaintext highlighter-rouge">B.show()</code> is called and prints <code class="language-plaintext highlighter-rouge">B</code>. It also calls <code class="language-plaintext highlighter-rouge">super().show()</code>, which refers to <code class="language-plaintext highlighter-rouge">C</code>, the next in the MRO.</li> <li><code class="language-plaintext highlighter-rouge">C.show()</code> is executed and prints <code class="language-plaintext highlighter-rouge">C</code>. It calls <code class="language-plaintext highlighter-rouge">super().show()</code>, which moves to <code class="language-plaintext highlighter-rouge">A</code>.</li> <li><code class="language-plaintext highlighter-rouge">A.show()</code> is executed and prints <code class="language-plaintext highlighter-rouge">A</code>. Since <code class="language-plaintext highlighter-rouge">A</code> doesn’t have a <code class="language-plaintext highlighter-rouge">super().show()</code> call, the chain ends there.</li> </ul> </li> </ul> <h2 id="learnings">Learnings</h2> <ol> <li>Method Resolution Order (MRO): The MRO determines the order in which classes are checked when a method is called. It is calculated using the C3 linearization algorithm, which ensures that the inheritance hierarchy is respected without ambiguity. Note that the MRO is unique for each class yet the MRO of a subclass is still consistent with the MRO of its parent class.</li> </ol> <p>The MRO of a class can be checked with the <code class="language-plaintext highlighter-rouge">__mro__</code> attribute or the <code class="language-plaintext highlighter-rouge">mro()</code> method.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nf">print</span><span class="p">(</span><span class="n">D</span><span class="p">.</span><span class="n">__mro__</span><span class="p">)</span>
<span class="c1"># Output: (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
</span>
</code></pre></div></div> <ol> <li>C3 Linearisation Algorithm: This algorithm determines the MRO for each class. It works by merging the MROs of the direct parent classes and the list of parent classes themselves. The C3 linearisation algorithm follows the following principles: <ul> <li>Preserve the local precedence order: If a class <code class="language-plaintext highlighter-rouge">B</code> inherits from a class <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> should appear before <code class="language-plaintext highlighter-rouge">A</code> in the MRO for class <code class="language-plaintext highlighter-rouge">B</code> (and any other classes that inherit from class <code class="language-plaintext highlighter-rouge">B</code>).</li> <li>Consistent across all subclasses: The algorithm should work uniformly when building MROs of classes that have common ancestors.</li> <li>Avoid duplicate entries: Each class should appear only once in the MRO.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">super()</code>: The <code class="language-plaintext highlighter-rouge">super()</code> function doesn’t necessarily refer to the immediate parent class but instead follows the MRO. This is crucial in cases of multiple inheritance.</li> <li>Class Hierarchies: Understanding how Python resolves method calls in complex hierarchies can prevent unexpected behavior and bugs in class designs involving multiple inheritance.</li> </ol>]]></content><author><name>Patrick Capaldo</name></author><category term="puzzles"/><category term="python"/><summary type="html"><![CDATA[The order in which classes are inherited and methods are resolved.]]></summary></entry><entry><title type="html">PyPuzzle 03 Yield</title><link href="https://patrickcap.github.io/blog/2024/pypuzzle-03/" rel="alternate" type="text/html" title="PyPuzzle 03 Yield"/><published>2024-05-06T00:00:00+00:00</published><updated>2024-05-06T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2024/pypuzzle-03</id><content type="html" xml:base="https://patrickcap.github.io/blog/2024/pypuzzle-03/"><![CDATA[<p>This weeks PyPuzzle will test your knowledge of order of generator functions and the yield keyword.</p> <ul> <li>Generator functions</li> <li><code class="language-plaintext highlighter-rouge">yield</code> keyword</li> <li>Iterators and lazy evaluation</li> </ul> <p>Feel free to use an online Python compiler and interpreter like [this] (https://www.online-python.com/) to try running the code yourself. The answer is supplied below the code.</p> <h2 id="question">Question</h2> <p>What is the expected output of the following code? How does the <code class="language-plaintext highlighter-rouge">yield</code> keyword affect the function’s behaviour and why doesn’t it behave like a typical <code class="language-plaintext highlighter-rouge">return</code>?</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_generator</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Generator started</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Yielded </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">, pausing generator</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Initialize the generator function
</span><span class="n">gen</span> <span class="o">=</span> <span class="nf">my_generator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Step through the generator
</span><span class="nf">print</span><span class="p">(</span><span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>  <span class="c1"># What happens here?
</span>
</code></pre></div></div> <h2 id="hints">Hints</h2> <ol> <li>What is the difference between <code class="language-plaintext highlighter-rouge">yield</code> and <code class="language-plaintext highlighter-rouge">return</code>? Consider how many times <code class="language-plaintext highlighter-rouge">yield</code> allows the function to pause and resume.</li> <li>Try to visualize what the function does with each call to <code class="language-plaintext highlighter-rouge">next(gen)</code>. How does <code class="language-plaintext highlighter-rouge">my_generator()</code> know where to pick up after yielding a value?</li> <li>What might happen when <code class="language-plaintext highlighter-rouge">next(gen)</code> is called, but there are no more items to yield?</li> </ol> <h2 id="answer">Answer</h2> <ul> <li>The first call to <code class="language-plaintext highlighter-rouge">next(gen)</code> starts the generator, which prints “<code class="language-plaintext highlighter-rouge">Generator started"</code>, yields <code class="language-plaintext highlighter-rouge">0</code>, and then pauses.</li> <li>Each subsequent <code class="language-plaintext highlighter-rouge">next(gen)</code> call resumes from where it left off, yielding the next value in the sequence (<code class="language-plaintext highlighter-rouge">1</code>, then <code class="language-plaintext highlighter-rouge">2</code>), and printing a message after each yield.</li> <li>When <code class="language-plaintext highlighter-rouge">next(gen)</code> is called a fourth time, there are no more values to yield, so Python raises a <code class="language-plaintext highlighter-rouge">StopIteration</code> exception, indicating that the generator has been exhausted.</li> </ul> <p>Expected output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Generator started
0
Yielded 0, pausing generator
1
Yielded 1, pausing generator
2
Yielded 2, pausing generator
</code></pre></div></div> <h2 id="learnings">Learnings</h2> <ul> <li>Generator Functions and <code class="language-plaintext highlighter-rouge">yield</code>: Using <code class="language-plaintext highlighter-rouge">yield</code> in a function turns it into a generator function. Instead of returning a single result and terminating, it yields multiple values, pausing between each, and can resume execution each time it’s called.</li> <li>Lazy Evaluation: Generators allow Python to produce values on the fly, making them memory-efficient for large data sequences, as values are generated only when needed. This is also beneficial for asynchronous tasks that are input/output (I/O)-bound as you can yield control back to an event loop once the required resources are ready.</li> <li><code class="language-plaintext highlighter-rouge">StopIteration</code> Exception: When a generator has no more values to yield, calling <code class="language-plaintext highlighter-rouge">next()</code> raises a <code class="language-plaintext highlighter-rouge">StopIteration</code> exception, signaling that iteration has completed. This is handled automatically when used in a loop, like a for loop.</li> <li>Generator functions also make it possible to produce infinite sequences (like Fibonacci and prime numbers) without risking memory overload. You can produce as much as you like from an infinite sequence without actually storing the entire sequence.</li> <li>An analogy is like streaming a TV show. You don’t have to load all the episodes from every season of the TV show when you start. You simply load the first episode and start watching that. If you need to pause it and leave for a while, that is fine, if you keep watching and want to watch the second episode, then simply load it once the first one finishes.</li> </ul>]]></content><author><name>Patrick Capaldo</name></author><category term="puzzles"/><category term="python"/><summary type="html"><![CDATA[Generator functions and the yield keyword.]]></summary></entry><entry><title type="html">PyPuzzle 02 GIL</title><link href="https://patrickcap.github.io/blog/2024/pypuzzle-02/" rel="alternate" type="text/html" title="PyPuzzle 02 GIL"/><published>2024-04-29T00:00:00+00:00</published><updated>2024-04-29T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2024/pypuzzle-02</id><content type="html" xml:base="https://patrickcap.github.io/blog/2024/pypuzzle-02/"><![CDATA[<p>This weeks PyPuzzle will help you understand the Global Interpreter Lock (GIL) in Python and how it affects multithreading, especially with CPU-bound tasks.</p> <h2 id="topics-covered">Topics Covered</h2> <ul> <li>Global Interpreter Lock (GIL)</li> <li>Threading and CPU-bound tasks</li> <li>Race conditions</li> </ul> <p>Feel free to use an online Python compiler and interpreter like [this] (https://www.online-python.com/) to try running the code yourself. The answer is supplied below the code.</p> <h2 id="question">Question</h2> <p>Given the following code, what do you expect the final value of <code class="language-plaintext highlighter-rouge">counter</code> to be after both threads finish? Run the code multiple times to observe any variations. What does this tell you about the GIL’s impact on multithreading in Python?</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">threading</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1"># Global counter
</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">increment</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">counter</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">run_threads</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">counter</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset the counter before each run
</span>
    <span class="c1"># Create two threads that both increment the counter
</span>    <span class="n">thread1</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">increment</span><span class="p">)</span>
    <span class="n">thread2</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">increment</span><span class="p">)</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

    <span class="c1"># Start both threads
</span>    <span class="n">thread1</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="n">thread2</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

    <span class="c1"># Wait for both threads to complete
</span>    <span class="n">thread1</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
    <span class="n">thread2</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>

    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Final counter:</span><span class="sh">"</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Time taken:</span><span class="sh">"</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>

<span class="c1"># Run the threads
</span><span class="nf">run_threads</span><span class="p">()</span>

</code></pre></div></div> <h2 id="hints">Hints</h2> <ol> <li>Think about the Global Interpreter Lock (GIL): Can both threads execute Python code at exactly the same time?</li> <li>Why might counter not equal 2,000,000, even though each thread attempts to increment it by 1 million?</li> <li>Try running the code multiple times. Does the output stay consistent?</li> <li>Quickly research what a CPU-bound task is. How does it differ from an I/O-bound task?</li> </ol> <h2 id="answer">Answer</h2> <p>Due to the GIL and lack of thread-safety, the expected output (2,000,000) is often not achieved. Instead, you’ll typically see a value lower than 2,000,000 due to race conditions. The threads compete to update <code class="language-plaintext highlighter-rouge">counter</code>, but because of the GIL, only one thread can execute at a time. As they interleave, they may overwrite each other’s updates, resulting in a lower <code class="language-plaintext highlighter-rouge">counter</code> value.</p> <p>Expected output (specific numbers subject to change):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Final counter: 1323157
Time taken: 0.6897156238555908
</code></pre></div></div> <h2 id="learnings">Learnings</h2> <ol> <li>Global Interpreter Lock (GIL): The GIL prevents true parallelism in Python for CPU-bound tasks because only one thread can execute Python bytecode at a time.</li> <li>CPU-bound Tasks: For tasks that require heavy CPU processing, the GIL limits the benefit of adding more threads. For such tasks, consider using multiprocessing to achieve true parallelism across multiple CPU cores.</li> <li>Race Conditions: Multithreading with shared resources like counter can lead to race conditions, where threads interfere with each other’s updates, producing inconsistent results.</li> <li>Performance and Consistency: The GIL introduces trade-offs between safety and performance in multithreading, especially for CPU-bound tasks, underscoring why threading in Python is more effective for I/O-bound rather than CPU-bound workloads.</li> </ol> <h2 id="further-reading">Further Reading</h2> <ul> <li> <p>CPU-bound tasks are those that spend most of their time waiting for the CPU to finish processing instructions (and thus most of their time hogging the GIL). This is compared to Input/Output (I/O)-bound tasks which spend most of their time waiting for an external event (e.g., network response, reading from a file, database access) to continue the task (and thus can free-up the GIL for a different task).</p> </li> <li> <p>The Global Interpreter Lock (GIL) is a safety mechanism in Python that prevents having multiple threads running at the same time (even if you have multiple CPU cores available where each can hold a single thread at a time).</p> </li> <li> <p>Interestingly, the GIL is mainly a feature of CPython (the default implementation of Python that is written using the C programming language). There are other implementations of Python like PyPy, Jython, and IronPython that are written in other programming languages like Python itself, Java, and C#, respectively. For multithreading, C is not an inherently safe programming language as C allows direct memory access. This means that if two threads were running simultaneously on the same memory, they could access a common memory address that is shared between them. And since processes don’t always take the exact same amount of time to run, this can lead to race conditions and combined with shared memory this would lead to unexpected behaviour, memory leaks, or even crashes. Additionally, since the main implementation of Python, CPython, is based on C, this means that the main implementation of Python is also not inherently safe for multithreading. Thus, the GIL was implemented to ensure only one thread executes at any given time to prevent simultaneous modifications of shared memory.</p> </li> <li> <p>Python could be made safe for multithreading by modifying the underlying CPython code but this would add a significant computational overhead to all Python programs, even the ones that don’t use multithreading (which turns out to be the majority). Being a reliable and thread safe language out-of-the-box is also appealing to extension developers like <code class="language-plaintext highlighter-rouge">NumPy</code> and <code class="language-plaintext highlighter-rouge">Pandas</code> as it means they don’t need to worry about thread safety themselves.</p> </li> </ul>]]></content><author><name>Patrick Capaldo</name></author><category term="puzzles"/><category term="python"/><summary type="html"><![CDATA[How the Global Interpreter Lock (GIL) handles threads.]]></summary></entry><entry><title type="html">PyPuzzle 01 Scope</title><link href="https://patrickcap.github.io/blog/2024/pypuzzle-01/" rel="alternate" type="text/html" title="PyPuzzle 01 Scope"/><published>2024-04-22T00:00:00+00:00</published><updated>2024-04-22T00:00:00+00:00</updated><id>https://patrickcap.github.io/blog/2024/pypuzzle-01</id><content type="html" xml:base="https://patrickcap.github.io/blog/2024/pypuzzle-01/"><![CDATA[<p>This weeks PyPuzzle will test your knowledge of order of execution, operator precedence, and scope.</p> <ul> <li>Execution Order: Tracking the order of statements and the effect of function calls.</li> <li>Operator Precedence: Understanding how <code class="language-plaintext highlighter-rouge">x = x + y</code> works when <code class="language-plaintext highlighter-rouge">x</code> is global.</li> <li>Variable Scope: Understanding <code class="language-plaintext highlighter-rouge">global</code>, <code class="language-plaintext highlighter-rouge">nonlocal</code>, and local scopes.</li> </ul> <p>Feel free to use an online Python compiler and interpreter like [this] (https://www.online-python.com/) to try running the code yourself. The answer is supplied below the code.</p> <h2 id="question">Question</h2> <p>What is the expected output of the following code?</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">puzzle</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">y</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Inside inner:</span><span class="sh">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="nf">inner</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Inside puzzle:</span><span class="sh">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="nf">puzzle</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Outside puzzle:</span><span class="sh">"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

</code></pre></div></div> <h2 id="answer">Answer</h2> <p>After <code class="language-plaintext highlighter-rouge">puzzle()</code> runs:</p> <ol> <li><code class="language-plaintext highlighter-rouge">x</code> in the global scope is updated to <code class="language-plaintext highlighter-rouge">15</code> (from <code class="language-plaintext highlighter-rouge">x + y = 5 + 10</code>).</li> <li><code class="language-plaintext highlighter-rouge">inner()</code> modifies <code class="language-plaintext highlighter-rouge">y</code> in <code class="language-plaintext highlighter-rouge">puzzle()</code> to <code class="language-plaintext highlighter-rouge">20</code>.</li> <li>The <code class="language-plaintext highlighter-rouge">print()</code> inside <code class="language-plaintext highlighter-rouge">inner()</code> outputs <code class="language-plaintext highlighter-rouge">Inside inner: 15 20</code>.</li> <li>The <code class="language-plaintext highlighter-rouge">print()</code> inside <code class="language-plaintext highlighter-rouge">puzzle()</code> outputs <code class="language-plaintext highlighter-rouge">Inside puzzle: 15 20</code>.</li> <li>Finally, <code class="language-plaintext highlighter-rouge">print("Outside puzzle:", x)</code> outputs <code class="language-plaintext highlighter-rouge">Outside puzzle: 15</code>.</li> </ol> <p>Expected output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Inside inner: 15 20
Inside puzzle: 15 20
Outside puzzle: 15
</code></pre></div></div> <h2 id="learnings">Learnings</h2> <ul> <li>That different parts (functions) of Python code have different world views (scopes).</li> <li>These scopes are defined by the level of the function (indicated by indentation) and the level of the variable (indicated by keywords like <code class="language-plaintext highlighter-rouge">global</code> and <code class="language-plaintext highlighter-rouge">nonlocal</code>).</li> </ul>]]></content><author><name>Patrick Capaldo</name></author><category term="puzzles"/><category term="python"/><summary type="html"><![CDATA[Execution order, operator precedence, and scope.]]></summary></entry></feed>